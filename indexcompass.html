<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/htmx.org@1.9.12" integrity="sha384-ujb1lZYygJmzgSwoxRggbCHcjc0rB2XoQrxeTUQyRjrOnlCoYta87iKBWq3EsdM2" crossorigin="anonymous"></script>
</head>
<body>
    <div id="uid" style="display: none"></div>
    <div id="location" hx-post="/gps" hx-trigger="sendGPS" hx-vals='{"rotation": {}, "location": {}}' style="display: none"></div>
    <button onclick="startGPS()" type="button" id="startButton" hx-get="/start" hx-trigger="click" hx-target="#uid" hx-vals='{"rotation": {}, "location": {}}'>Start</button> 

    <div class="p-3 mb-2 bg-secondary" id="demo-div">
        <p style="margin-top:1rem;">Num. of datapoints: <span class="badge badge-warning" id="num-observed-events">0</span></p>
        
        <h4 style="margin-top:0.75rem;">Orientation</h4>
        <ul>
            <li>X-axis (&beta;): <span id="Orientation_b">0</span><span>&deg;</span></li>
            <li>Y-axis (&gamma;): <span id="Orientation_g">0</span><span>&deg;</span></li>
            <li>Z-axis (&alpha;): <span id="Orientation_a">0</span><span>&deg;</span></li>
        </ul>
    </div>

    <script>
        let userId;
        const button = document.getElementById('startButton');

        // Event listeners
        document.body.addEventListener('htmx:afterSwap', function(evt) {
            userId = evt.detail.target.innerHTML;
        });

        // Handle orientation
        // Add the Magnetometer API handling
        let magnetometerData = null;
        let accelerometerData = null;

        function handleMagnetometer() {
            // Check if the Magnetometer API is supported
            if ('Magnetometer' in window) {
                // Create a new instance of the Magnetometer with a specified frequency (e.g., 60 Hz)
                const sensor = new Magnetometer({ frequency: 60 });

                // Add an event listener for the sensor's readings
                sensor.addEventListener('reading', () => {
                    magnetometerData = {
                        x: sensor.x,
                        y: sensor.y,
                        z: sensor.z
                    };

                    // Calculate heading when both accelerometer and magnetometer data are available
                    calculateHeading();
                });

                // Add an error handler for sensor errors
                sensor.addEventListener('error', (event) => {
                    console.error(`Magnetometer error: ${event.error}`);
                });

                // Start the sensor
                sensor.start();
            } else {
                console.log('Magnetometer API is not supported on this browser.');
            }
        }

        function handleAccelerometer() {
            // Check if the Accelerometer API is supported
            if ('Accelerometer' in window) {
                // Create a new instance of the Accelerometer with a specified frequency (e.g., 60 Hz)
                const sensor = new Accelerometer({ frequency: 60 });

                // Add an event listener for the sensor's readings
                sensor.addEventListener('reading', () => {
                    accelerometerData = {
                        x: sensor.x,
                        y: sensor.y,
                        z: sensor.z
                    };

                    // Calculate heading when both accelerometer and magnetometer data are available
                    calculateHeading();
                });

                // Add an error handler for sensor errors
                sensor.addEventListener('error', (event) => {
                    console.error(`Accelerometer error: ${event.error}`);
                });

                // Start the sensor
                sensor.start();
            } else {
                console.log('Accelerometer API is not supported on this browser.');
            }
        }

        function calculateHeading() {
            // Only calculate the heading if both magnetometer and accelerometer data are available
            if (magnetometerData && accelerometerData) {
                // Calculate the tilt angles
                const pitch = Math.atan2(accelerometerData.x, Math.sqrt(accelerometerData.y**2 + accelerometerData.z**2));
                const roll = Math.atan2(accelerometerData.y, accelerometerData.z);

                // Calculate heading relative to magnetic north using the magnetometer data
                const magX = magnetometerData.x * Math.cos(pitch) + magnetometerData.y * Math.sin(pitch) * Math.sin(roll) - magnetometerData.z * Math.sin(pitch) * Math.cos(roll);
                const magY = magnetometerData.y * Math.cos(roll) + magnetometerData.z * Math.sin(roll);

                // Calculate the heading in degrees
                const heading = Math.atan2(magY, magX) * (180 / Math.PI);

                // Normalize the heading to 0-360 degrees
                const normalizedHeading = (heading + 360) % 360;

                // Parse the current hx-vals attribute value from the button
                let hxValsObject = JSON.parse(button.getAttribute('hx-vals'));

                // Update rotation data in hx-vals
                hxValsObject.rotation = {
                    alpha: normalizedHeading,
                };

                // Convert the updated hx-vals object back to a JSON string and set it as the attribute value
                button.setAttribute('hx-vals', JSON.stringify(hxValsObject));

                // Update the orientation display on the page
                updateFieldIfNotNull('Orientation_a', normalizedHeading);
            }
        }

        // Initialize the magnetometer and accelerometer handling
        handleMagnetometer();
        handleAccelerometer();





        // Update fields if value is not null
        function updateFieldIfNotNull(fieldName, value, precision = 1) {
            if (value !== null) {
                document.getElementById(fieldName).innerHTML = value.toFixed(precision);
            }
        }

        // Increment event count
        function incrementEventCount() {
            let counterElement = document.getElementById("num-observed-events");
            let eventCount = parseInt(counterElement.innerHTML);
            counterElement.innerHTML = eventCount + 1;
        }

        // Start GPS tracking
        function startGPS() {
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(check, error, {
                    enableHighAccuracy: false,
                    timeout: 10000,
                    maximumAge: 0,
                });
            }
        }

        // Check GPS location
        function check(pos) {
            if (userId !== null) {
                // Parse the current hx-vals attribute value from the button
                let hxValsObject = JSON.parse(button.getAttribute('hx-vals'));

                // Update location data in hx-vals
                const locationData = {
                    latitude: pos.coords.latitude,
                    longitude: pos.coords.longitude
                };

                hxValsObject.location = locationData;

                // Convert the updated hx-vals object back to a JSON string and set it as the attribute value
                button.setAttribute('hx-vals', JSON.stringify(hxValsObject));

                // Trigger the "sendGPS" event on #location to send the updated hx-vals data
                htmx.trigger("#location", "sendGPS", {});
            }
        }

        // Error handler for GPS
        function error(err) {
            console.error(`ERROR(${err.code}): ${err.message}`);
        }

        // Automatically click button every 50ms
        setInterval(() => {
            button.click();
        }, 500);
    </script>
</body>
</html>
